<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="chap-overview">

<title>Overview</title>

<para>This chapter gives a quick overview of how to use NixOps.</para>

<section><title>Deploying a VirtualBox VM</title>

<para>NixOps deploys machines on the basis of a declarative
description of what those machines should do, and where they should be
deployed to.  These descriptions are specified in the <emphasis>Nix
expression language</emphasis> used by the Nix package manager.  <xref
linkend="ex-logical.nix" /> shows a minimal specification of a network
consisting of only one logical machine named
<literal>webserver</literal>.</para>

<example xml:id="ex-logical.nix">
  <title><filename>trivial.nix</filename>: logical network specification</title>
<programlisting>
{
  network.description = "Web server";

  webserver =
    { config, pkgs, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot = "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];
    };
}
</programlisting>
</example>

<para>This specification consists of a set of top-level attributes
describing logical machines (namely <varname>webserver</varname>) and
meta-information (namely <varname>network.description</varname>).
Each attribute not named <varname>network</varname> describes a
logical machine.  The value of each logical machine attribute is a
<emphasis>NixOS configuration module</emphasis>, which describes the
desired configuration of the corresponding machine.  Thus, the logical
machine <literal>webserver</literal> should have the Apache
<command>httpd</command> web server running, and its document root
(rather arbitrarily for demonstration purposes) should be the
documentation of the Valgrind package.</para>

<para>To deploy this machine, we also need to provide configuration
options that tell NixOps to what environment it should be deployed.
<xref linkend="ex-physical-vbox.nix" /> specifies that
<literal>webserver</literal> should be deployed as a VirtualBox
instance. Note that for this to work the <literal>vboxnet0</literal> network has to exist - you can add it in the VirtualBox general settings under <emphasis>Networks - Host-only Networks</emphasis> if necessary.
If you are running NixOps in a headless environment, then you should also add the option
<code>deployment.virtualbox.headless = true;</code>
to the configuration. Otherwise, VirtualBox will fail when it tries to open a graphical display on the host's desktop.</para>

<example xml:id="ex-physical-vbox.nix">
  <title><filename>trivial-vbox.nix</filename>: VirtualBox physical network specification</title>
<programlisting>
{
  webserver =
    { config, pkgs, ... }:
    { deployment.targetEnv = "virtualbox";
      deployment.virtualbox.memorySize = 1024; # megabytes
      deployment.virtualbox.vcpu = 2; # number of cpus
    };
}
</programlisting>
</example>

<para>Before we can deploy the network we need to use the command
<command>nixops create</command> to create a <emphasis>NixOps
deployment</emphasis> that contains any state associated with the
deployment (such as information about instantiated VMs).  At creation
time, we need to specify the Nix expressions that constitute the
complete deployment specification.  So to create a deployment for
deploying the Apache web server to VirtualBox, we would do:

<screen>
$ nixops create ./trivial.nix ./trivial-vbox.nix -d trivial
33bced96-5f26-11e1-b9d7-9630d48abec1
</screen>

Here <literal>-d trivial</literal> gives the symbolic name
<literal>trivial</literal> to the deployment.  Deployments can be
identified in two ways: using the UUID printed by <command>nixops
create</command>, or using the symbolic name you specified at creation
time.</para>

<para>You can print a list of existing deployments using
<command>nixops list</command>:

<screen>
+--------------------------------------+-----------+--------------+------------+------------+
|                 UUID                 |   Name    | Description  | # Machines |    Type    |
+--------------------------------------+-----------+--------------+------------+------------+
| 33bced96-5f26-11e1-b9d7-9630d48abec1 |  trivial  |  Web server  |     0      |            |
+--------------------------------------+-----------+--------------+------------+------------+
</screen>
</para>

<para>The command <command>nixops info</command> shows the current
deployment state:

<screen>
$ nixops info -d trivial
Network UUID: 33bced96-5f26-11e1-b9d7-9630d48abec1
Network description: Web server

+-----------+--------+------------+-------------+------------+
|   Name    | Status |    Type    | Resource Id | IP address |
+-----------+--------+------------+-------------+------------+
| webserver |  New   | virtualbox |             |            |
+-----------+--------+------------+-------------+------------+
</screen>

The machine status <literal>New</literal> indicates that the logical
machine <literal>webserver</literal> hasn’t been created yet.  The
<option>-d</option> option specifies which deployment to use; you can
use the symbolic name (<literal>-d trivial</literal>) or the UUID
(<literal>-d 33bced96-5f26-11e1-b9d7-9630d48abec1</literal>).  You
can also set the the environment variable
<envar>NIXOPS_DEPLOYMENT</envar>.</para>

<para>The actual deployment is done by running <command>nixops
deploy</command>:

<screen>
$ nixops deploy -d trivial
creating VirtualBox VM ‘webserver’...
Virtual machine 'nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver' is created and registered.
Clone hard disk created in format 'VDI'. UUID: 5a0b0771-7e03-4fab-9c2f-e95888b57db3
Waiting for VM "nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver" to power on...
VM "nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-webserver" has been successfully started.
waiting for IP address of ‘webserver’........................... 192.168.56.101
waiting for SSH on ‘webserver’...
building all machine configurations...
building path(s) `/nix/store/ybrny9h744q8i3x026ccfmdav8qnw7pd-nixos-version'
building path(s) `/nix/store/zxw279xhl6l8yl94gnka8aqv1kkcrrd4-os-release'
fetching path `/nix/store/pn43d3llpsm3pc1ywaxccmw8pmzjqgz0-valgrind-3.7.0'...
…
copying closure to machine ‘webserver’...
copying 376 missing paths to ‘root@192.168.56.101’...
importing path `/nix/store/jfcs9xnfbmiwqs224sb0qqsybbfl3sab-linux-headers-2.6.35.14'
…
activating new configuration on machine ‘webserver’...
updating GRUB 2 menu...
activating the configuration...
…
starting new service ‘httpd’...
</screen>

NixOps performs the following steps to do the deployment:

<itemizedlist>

  <listitem><para>It creates missing machines.  In this case, a
  VirtualBox instance for the logical machine
  <literal>webserver</literal> is started.  NixOps then waits to
  obtain its IP address.</para></listitem>

  <listitem><para>It builds the NixOS machine configurations locally.
  For instance, here Valgrind is built or downloaded because our
  machine configuration has a dependency on it.</para></listitem>

  <listitem><para>It copies the closure of each machine configuration
  to the corresponding machine.</para></listitem>

  <listitem><para>It activates the configuration on each machine.  For
  instance, it starts the <literal>httpd</literal> systemd service on
  the <literal>webserver</literal> machine.  This is the only step
  that has a visible effect; all prior steps do not affect the active
  configuration of the machines.</para></listitem>

</itemizedlist>

</para>

<para>The <command>nixops info</command> command will show that a
machine was created:

<screen>
$ nixops info -d trivial
Network UUID: 33bced96-5f26-11e1-b9d7-9630d48abec1
Network description: Web server

+-----------+--------+------------+-----------------------------------------------------+----------------+
|   Name    | Status |    Type    |                    Resource Id                      |   IP address   |
+-----------+--------+------------+-----------------------------------------------------+----------------+
| webserver |   Up   | virtualbox | nixops-33bced96-5f26-11e1-b9d7-9630d48abec1-machine | 192.168.56.101 |
+-----------+--------+------------+-----------------------------------------------------+----------------+
</screen>

</para>

<para>Visit <literal>http://192.168.56.101</literal> in a web browser
should now show the Valgrind documentation.  You can also log in to
the virtual machine as <literal>root</literal>:

<screen>
$ nixops ssh -d trivial webserver
connecting to 192.168.56.101...
[root@webserver:~]#
</screen>

The command <command>nixops ssh</command> is a convenience wrapper
around <command>ssh</command> that passes the right IP address and SSH
identity for the specified logical machine.  (NixOps automatically
creates a unique SSH key pair for communicating with each VirtualBox
instance.)</para>

<para>Redeployment after making a change to the specification is
simply a matter of running <command>nixops deploy</command> again.  If
we do this for the example, NixOps will notice that the
<literal>webserver</literal> machine already exists and that most or
all dependencies are already present, so it won’t create a new
VirtualBox instance or need to build and copy a lot of dependencies.
Thus redeployment typically only takes a few seconds:

<screen>
$ time nixops deploy -d trivial
building all machine configurations...
copying closure to machine ‘webserver’...
activating new configuration on machine ‘webserver’...
real    0m3.700s
</screen>

</para>

<para>If you want to get rid of the virtual machines created by
NixOps, you can run <command>nixops destroy</command>:

<screen>
$ nixops destroy -d trivial
warning: are you sure you want to destroy VirtualBox VM ‘webserver’? (y/N) y
webserver> destroying VirtualBox VM...
webserver> 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
webserver> 0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%
</screen>

You can use the option <option>--confirm</option> to confirm all
questions.  This is useful for automated deployment, but potentially
dangerous.</para>



<section><title>Deploying multiple machines</title>

<para>A network consisting of only one logical machine is not very
exciting.  <xref linkend="ex-logical-multi.nix" /> shows a network
consisting of three machines: a load balancer (named
<literal>proxy</literal>) that uses Apache’s
<literal>mod_proxy</literal> to do reverse proxying, and two backend
web servers (<literal>backend1</literal> and
<literal>backend2</literal>) that serve the actual content.  One
important thing to note is that if you want to refer to another
machine (e.g. in a configuration file), you can use a hostname equal
to the logical name of the machine, as in the line

<programlisting>
BalancerMember http://backend1 retry=0
</programlisting>

This works because NixOps generates a <filename>/etc/hosts</filename>
file that contains entries for all the logical machines in the
network, mapping names to each machine’s IP address.  Also note that
because the two backend machines have identical configurations, we can
use a let-binding to define the configuration only once.</para>

<example xml:id="ex-logical-multi.nix">
  <title><filename>load-balancer.nix</filename>: logical network specification</title>
<programlisting>
let

  backend =
    { config, pkgs, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "alice@example.org";
      services.httpd.documentRoot = "${pkgs.valgrind.doc}/share/doc/valgrind/html";
      networking.firewall.allowedTCPPorts = [ 80 ];
    };

in

{
  network.description = "Load balancing network";

  proxy =
    { config, pkgs, nodes, ... }:
    { services.httpd.enable = true;
      services.httpd.adminAddr = "bob@example.org";
      services.httpd.extraModules = ["proxy_balancer" "lbmethod_byrequests"];
      services.httpd.extraConfig =
        ''
          &lt;Proxy balancer://cluster>
            Allow from all
            BalancerMember http://backend1 retry=0
            BalancerMember http://backend2 retry=0
          &lt;/Proxy>
          ProxyPass         /    balancer://cluster/
          ProxyPassReverse  /    balancer://cluster/
        '';
      networking.firewall.allowedTCPPorts = [ 80 ];
    };

  backend1 = backend;
  backend2 = backend;
}
</programlisting>
</example>

<para>To deploy it, we need a physical specification, shown in <xref
linkend="ex-physical-multi.nix" />.  Deployment is as follows:

<screen>
$ nixops create ./load-balancer.nix ./load-balancer-vbox.nix -d load-balancer-vbox
$ nixops deploy -d load-balancer-vbox
</screen>

Note that NixOps creates and deploys the VMs in parallel to speed
things up.</para>

<example xml:id="ex-physical-multi.nix">
  <title><filename>load-balancer-vbox.nix</filename>: VirtualBox physical network specification</title>
<programlisting>
let
  vbox = { deployment.targetEnv = "virtualbox"; };
in
{ proxy    = vbox;
  backend1 = vbox;
  backend2 = vbox;
}
</programlisting>
</example>

</section>

</section>

<section xml:id="sec-deploying-to-physical-nixos"><title>Deploying to a NixOS machine</title>

<para>To deploy to a machine that is already running NixOS, simply set
<varname>deployment.targetHost</varname> to the IP address or host name of the machine,
and leave <varname>deployment.targetEnv</varname> undefined.
See <xref linkend="ex-physical-nixos.nix" />.
</para>

<example xml:id="ex-physical-nixos.nix">
  <title><filename>trivial-nixos.nix</filename>: NixOS target physical network specification</title>
<programlisting>
{
  webserver =
    { config, pkgs, ... }:
    { deployment.targetHost = "1.2.3.4";
    };
}
</programlisting>
</example>

</section>

<section><title>Accessing machines</title>

<para>We have seen above that you can login to individual machines by
doing <literal>nixops ssh <replaceable>name</replaceable></literal>,
where <replaceable>name</replaceable> is the name of the
machine.</para>

<para>It’s also possible to perform a command on all machines:

<screen>
$ nixops ssh-for-each -d load-balancer-ec2 -- df /tmp
backend1...> /dev/xvdb      153899044 192084 145889336   1% /tmp
proxy......> /dev/xvdb      153899044 192084 145889336   1% /tmp
backend2...> /dev/xvdb      153899044 192084 145889336   1% /tmp
</screen>

By default, the command is executed sequentially on each machine.  You
can add the flag <option>-p</option> to execute it in parallel.</para>

</section>


<section><title>Checking machine status</title>

<para>The command <command>nixops check</command> checks the status of
each machine in a deployment.  It verifies that the machine still
exists (i.e. hasn’t been destroyed outside of NixOps), is up (i.e. the
instance has been started) and is reachable via SSH.  It also checks
that any attached disks (such as EBS volumes) are not in a failed
state, and prints the names of any systemd units that are in a failed
state.</para>

<para>For example, for the 3-machine EC2 network shown above, it might
show:

<screen>
$ nixops check -d load-balancer-ec2
+----------+--------+-----+-----------+----------+----------------+---------------+-------+
| Name     | Exists | Up  | Reachable | Disks OK | Load avg.      | Failed units  | Notes |
+----------+--------+-----+-----------+----------+----------------+---------------+-------+
| backend1 | Yes    | Yes | Yes       | Yes      | 0.03 0.03 0.05 | httpd.service |       |
| backend2 | Yes    | No  | N/A       | N/A      |                |               |       |
| proxy    | Yes    | Yes | Yes       | Yes      | 0.00 0.01 0.05 |               |       |
+----------+--------+-----+-----------+----------+----------------+---------------+-------+
</screen>

This indicates that Apache httpd has failed on
<literal>backend1</literal> and that machine
<literal>backend2</literal> is not running at all.  In this situation,
you should run <command>nixops deploy --check</command> to repair the
deployment.</para>

</section>

<section><title>Network special attributes</title>

<para>
It is possible to define special options for the whole network. For example:

<screen>
{
  network = {
    description = "staging environment";
    enableRollback = true;
  };

  defaults = {
    imports = [ ./common.nix ];
  };

  machine = { ... }: {};
}
</screen>

Each attribute is explained below:

</para>


<variablelist>

  <varlistentry><term><option>defaults</option></term>

    <listitem><para>Applies given NixOS module to all machines defined in the network.
    </para></listitem>

  </varlistentry>

  <varlistentry><term><option>network.description</option></term>

    <listitem><para>A sentence describing the purpose of the network
    for easier comparison when running <command>nixops list</command>
    </para></listitem>

  </varlistentry>

  <varlistentry><term><option>network.enableRollback</option></term>

  <listitem><para>If <literal>true</literal>, each deployment creates
  a new profile generation to able to run <command>nixops rollback</command>.
  Defaults to <literal>false</literal>.
  </para></listitem>

  </varlistentry>

</variablelist>


</section>

<section><title>Network arguments</title>

<para>In NixOps you can pass in arguments from outside the nix
expression. The network file can be a nix function, which takes a set
of arguments which are passed in externally and can be used to change
configuration values, or even to generate a variable number of
machines in the network.</para>

<para>Here is an example of a network with network arguments:

<screen>
{ maintenance ? false
}:
{
  machine =
    { config, pkgs, ... }:
    { services.httpd.enable = maintenance;
      ...
    };
}
</screen>

This network has a <emphasis>maintenance</emphasis> argument that
defaults to <code>false</code>. This value can be used inside the
network expression to set NixOS option, in this case whether or not
Apache HTTPD should be enabled on the system.
</para>

<para>
You can pass network arguments using the <code>set-args</code> nixops
command. For example, if we want to set the <code>maintenance</code>
argument to <code>true</code> in the previous example, you can run:

<screen>
  $ nixops set-args --arg maintenance true -d &lt;name&gt;
</screen>

The arguments that have been set will show up:

<screen>
$ nixops info -d argtest
Network name: argtest
Network UUID: 634d6273-f9f6-11e2-a004-15393537e5ff
Network description: Unnamed NixOps network
Nix expressions: .../network-arguments.nix
<emphasis>Nix arguments: maintenance = true</emphasis>

+---------+---------------+------+-------------+------------+
| Name    |     Status    | Type | Resource Id | IP address |
+---------+---------------+------+-------------+------------+
| machine | Missing / New | none |             |            |
+---------+---------------+------+-------------+------------+

</screen>

Running <code>nixops deploy</code> after changing the arguments will
deploy the new configuration.

</para>

</section>

<section>
  <title>Managing keys</title>

  <para>
    Files in <filename>/nix/store/</filename> are readable by every
    user on that host, so storing secret keys embedded in nix derivations
    is insecure. To address this, nixops provides the configuration
    option <varname>deployment.keys</varname>, which nixops manages
    separately from the main configuration derivation for each machine.
  </para>

  <para>
    Add a key to a machine like so.

    <screen>
{
  machine =
    { config, pkgs, ... }:
    {
      deployment.keys.my-secret.text = "shhh this is a secret";
      deployment.keys.my-secret.user = "myuser";
      deployment.keys.my-secret.group = "wheel";
      deployment.keys.my-secret.permissions = "0640";
    };
}
    </screen>

    This will create a file <filename>/run/keys/my-secret</filename>
    with the specified contents, ownership, and permissions.
  </para>

  <para>
    Among the key options, only <varname>text</varname> is required. The
    <varname>user</varname> and <varname>group</varname> options both default
    to <literal>"root"</literal>, and <varname>permissions</varname> defaults
    to <literal>"0600"</literal>.
  </para>

  <para>
    Keys from <varname>deployment.keys</varname> are stored under <filename>/run/</filename>
    on a temporary filesystem and will not persist across a reboot.
    To send a rebooted machine its keys, use <command>nixops send-keys</command>. Note that all
    <command>nixops</command> commands implicitly upload keys when appropriate,
    so manually sending keys should only be necessary after an unattended reboot.
  </para>

  <para>
    If you have a custom service that depends on a key from <varname>deployment.keys</varname>,
    you can opt to let systemd track that dependency. Each key gets a corresponding
    systemd service <literal>"${keyname}-key.service"</literal> which is active
    while the key is present, and otherwise inactive when the key is absent. See
    <xref linkend="key-dependency.nix" /> for how to set this up.

    <example xml:id="key-dependency.nix">
      <title><filename>key-dependency.nix</filename>: track key dependence with systemd</title>
      <programlisting>
{
  machine =
    { config, pkgs, ... }:
    {
      deployment.keys.my-secret.text = "shhh this is a secret";

      systemd.services.my-service = {
        after = [ "my-secret-key.service" ];
        wants = [ "my-secret-key.service" ];
        script = ''
          export MY_SECRET=$(cat /run/keys/my-secret)
          run-my-program
        '';
      };
    };
}
      </programlisting>
    </example>

    These dependencies will ensure that the service is only started when the keys it
    requires are present. For example, after a reboot, the services will be delayed
    until the keys are available, and <command>systemctl status</command> and friends
    will lead you to the cause.
  </para>
</section>

<section>
  <title>Special NixOS module inputs</title>
  <para>
    In deployments with multiple machines, it is often convenient to access the
    configuration of another node in the same network, e.g. if you want to
    store a port number only once.  </para>
  <para>
    This is possible by using the extra NixOS module input <literal>nodes</literal>.
  </para>
  <para>
    <programlisting>
{
  network.description = "Gollum server and reverse proxy";

  gollum =
    { config, pkgs, ... }:
    { 
      services.gollum = {
        enable = true;
        port = 40273;
      };
      networking.firewall.allowedTCPPorts = [ config.services.gollum.port ];
    };

  reverseproxy =
    { config, pkgs, nodes, ... }:
    let
      gollumPort = nodes.gollum.config.services.gollum.port;
    in
    { 
      services.nginx = {
        enable = true;
        virtualHosts."wiki.example.net".locations."/" = {
          proxyPass = "http://gollum:${toString gollumPort}";
        };
      };
      networking.firewall.allowedTCPPorts = [ 80 ];
    };
}
    </programlisting>
  </para>
  <para>
    Moving the port number to a different value is now without the risk of an inconsistent deployment.
  </para>
  <para>
    Aditional module inputs are
  </para>
  <itemizedlist> 
    <listitem><para><literal>name</literal>: The name of the machine.</para></listitem>
    <listitem><para><literal>uuid</literal>: The NixOps UUID of the deployment.</para></listitem>
    <listitem><para><literal>resources</literal>: NixOps resources associated with the deployment.</para></listitem>
  </itemizedlist> 
</section>

<!--

<para>EC2 logical.nix</para>

<para>EC2 deployment</para>

<para>Multiple machines (load balancer)</para>

-->

</chapter>
